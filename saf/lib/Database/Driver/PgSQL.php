<?php
//
// +----------------------------------------------------------------------+
// | Sitellite - Content Management System								|
// +----------------------------------------------------------------------+
// | Copyright (c) 2001 Simian Systems									|
// +----------------------------------------------------------------------+
// | This software is released under the Simian Open Software License.	|
// | Please see the accompanying file OPENLICENSE for licensing details!  |
// |																	  |
// | You should have received a copy of the Simian Open Software License  |
// | along with this program; if not, write to Simian Systems,			|
// | 101-314 Broadway, Winnipeg, MB, R3C 0S7, CANADA.  The Simian		 |
// | Public License is also available at the following web site		   |
// | address: <http://www.sitellite.org/index/license>					  |
// +----------------------------------------------------------------------+
// | Authors: John Luxford <lux@simian.ca>								|
// +----------------------------------------------------------------------+
//
// PgSQL_Driver is the Database driver for the PostgreSQL database system.
//

/**
	 * PgSQL_Driver is the Database driver for the PostgreSQL database system.
	 * PgSQL_Query provides all of the PostgreSQL-specific functionality
	 * for Query objects.  It is accessed through the Database class API.
	 * 
	 * <code>
	 * <?php
	 * 
	 * $q = new PgSQL_Query ("select * from table");
	 * if ($q->execute ()) {
	 * 	while ($row = $q->fetch ()) {
	 * 		// do something with $row
	 * 	}
	 * 	$q->free ();
	 * } else {
	 * 	// query failed
	 * }
	 * 
	 * ? >
	 * </code>
	 * 
	 * @package	Database
	 * @author	John Luxford <lux@simian.ca>
	 * @copyright	Copyright (C) 2001-2003, Simian Systems Inc.
	 * @license	http://www.sitellite.org/index/license	Simian Open Software License
	 * @version	0.6, 2003-04-03, $Id: PgSQL.php,v 1.2 2005/07/06 15:30:56 lux Exp $
	 * @access	public
	 * 
	 */

class PgSQL_Query extends Query {
	/**
	 * Contains the SQL query to be executed.
	 * 
	 * @access	public
	 * 
	 */
	var $sql = '';

	/**
	 * Contains the result identifier for the current execution.
	 * 
	 * @access	public
	 * 
	 */
	var $result = '';

	/**
	 * Currently unused.
	 * 
	 * @access	public
	 * 
	 */
	var $field = '';

	/**
	 * The resource ID for the database connection to be queried.
	 * 
	 * @access	public
	 * 
	 */
	var $connection = '';

	/**
	 * Constructor method.
	 * 
	 * $sql is the SQL query you wish to execute with this object.
	 * $conn is the database connection resource to be queried.
	 * 
	 * @access	public
	 * @param	string	$sql
	 * @param	resource	$conn
	 * 
	 */
	function PgSQL_Query ($sql = '', &$conn, $cache = 0) {
		parent::Query ($sql, $conn, $cache);
	}

	/**
	 * Executes the current SQL query.
	 * 
	 * $values is an array of values to substitute.  The syntax for denoting
	 * bind_values in the SQL query is a double-questionmark (??).
	 * 
	 * Returns the new SQL query.  Note: does not modify the actual $sql property.
	 * 
	 * @access	public
	 * @param	array	$values
	 * @return	resource
	 * 
	 */
	function execute () {
		// call bind_values
		$this->bind_values (func_get_args ());

		if (parent::execute ()) {
			// if parent::execute () returns true, then we're using the cached copy,
			// so no need to query the database
			return true;
		}

		// query the database
		$this->result = @pg_query ($this->connection, $this->tmp_sql);
		return $this->result;
	}

	/**
	 * Returns the name of the specified column in the table currently being queried.
	 * 
	 * $num is the column number.  Note: Some database systems begin with
	 * column 0, while others with 1.
	 * 
	 * @access	public
	 * @param	integer	$num
	 * @return	string
	 * 
	 */
	function field ($num = 0) {
		if ($this->result) {
			if (! is_array ($this->fields)) {
				return @pg_field_name ($this->result, $num);
			} else {
				return $this->fields[$num];
			}
		} else {
			return 0;
		}
	}

	/**
	 * Returns the number of rows affected or found by the current query.
	 * This method differs from other drivers in that it accepts a single
	 * $useAffected parameter, which tells the driver to use the pg_affected_rows()
	 * function instead of pg_num_rows().  This should be set to 'true' on
	 * INSERT, UPDATE, and DELETE queries.
	 * 
	 * @access	public
	 * @param	boolean	$useAffected
	 * @return	integer
	 * 
	 */
	function rows ($useAffected = false) {
		if ($this->result) {
			if (empty ($this->rows)) {
				if ($useAffected) {
					return @pg_affected_rows ($this->result);
				} else {
					return @pg_num_rows ($this->result);
				}
			} else {
				return $this->rows;
			}
		} else {
			return 0;
		}
	}

	/**
	 * Returns the row ID generated by the database during the previous
	 * SQL insert query.
	 * 
	 * @access	public
	 * @return	integer
	 * 
	 */
	function lastid () {
		if ($this->result) {
			return @pg_last_id ($this->connection);
		} else {
			return 0;
		}
	}

	/**
	 * Returns the next row of data from the current query, always in the
	 * form of an object, with each column as its properties.
	 *
	 * MISSING: ($offset, $limit) optional parameters
	 * 
	 * @access	public
	 * @return	object
	 * 
	 */
	function fetch () {
		if ($this->result) {
			switch ($this->cache_action) {
				case 0:
					//print_r ($this);
					return @pg_fetch_object ($this->result);
				case 1:
					//print_r ($this);
					return parent::fetch ();
				case 2:
					//print_r ($this);
					$this->_row = @pg_fetch_object ($this->result);
					return parent::fetch ();
				case 3:
					//print_r ($this);
					$this->_row = @pg_fetch_object ($this->result);
					return parent::fetch ();
			}
		} else {
			//print_r ($this);
			return 0;
		}
	}

	/**
	 * Tells the database system to let go of its data from the previous
	 * query.
	 * 
	 * @access	public
	 * 
	 */
	function free () {
		parent::free ();
		if ($this->result) {
			return @pg_free_result ($this->result);
		}
	}

	/**
	 * Issues a mysql "begin" statement, beginning a transaction.
	 * 
	 * @access	public
	 * 
	 */
	function begin () {
		@pg_query ($this->connection, "begin work");
	}

	/**
	 * Issues a mysql "commit" statement, committing the current transaction.
	 * 
	 * @access	public
	 * 
	 */
	function commit () {
		@pg_query ($this->connection, "commit work");
	}

	/**
	 * Issues a mysql "rollback" statement, rolling back the current transaction.
	 * 
	 * @access	public
	 * 
	 */
	function rollback () {
		@pg_query ($this->connection, "rollback work");
	}

	/**
	 * Returns the database error number in case of error.  Always returns
	 * 0 for this driver, since there is no such function in the PostgreSQL
	 * extension.
	 * 
	 * @access	public
	 * @return	integer
	 * 
	 */
	function errno () {
		return 0; //@pg_result_error ($this->result);
	}

	/**
	 * Returns the database error message in case of error.
	 * 
	 * @access	public
	 * @return	string
	 * 
	 */
	function error () {
		return @pg_result_error ($this->result);
	}
}

/**
	 * PgSQL_Driver provides all of the PgSQL-specific functionality
	 * for Database objects.  It is accessed through the Database class API.
	 * 
	 * New in 1.2:
	 * - Added a close() method.
	 * 
	 * <code>
	 * <?php
	 * 
	 * $db = new PgSQL_Driver ("name", "host", "user", "pass", 1);
	 * 
	 * if ($db->connection) {
	 * 	// connection worked
	 * } else {
	 * 	// connection failed
	 * }
	 * 
	 * ?>
	 * </code>
	 * 
	 * @author	John Luxford <lux@simian.ca>
	 * @copyright	Copyright (C) 2001-2003, Simian Systems Inc.
	 * @license	http://www.sitellite.org/index/license	Simian Open Software License
	 * @version	1.2, 2002-07-16, $Id: PgSQL.php,v 1.2 2005/07/06 15:30:56 lux Exp $
	 * @access	public
	 * 
	 */

class PgSQL_Driver {
	/**
	 * Contains the database connection resource.
	 * 
	 * @access	public
	 * 
	 */
	var $connection;

	/**
	 * Contains the name of the database being used.
	 * 
	 * @access	public
	 * 
	 */
	var $name;

	/**
	 * Contains the name of the database host.
	 * 
	 * @access	public
	 * 
	 */
	var $host;

	/**
	 * Contains the username used to connect to the current database.
	 * 
	 * @access	public
	 * 
	 */
	var $user;

	/**
	 * Contains the password used to connect to the current database.
	 * 
	 * @access	public
	 * 
	 */
	var $pass;

	/**
	 * A 1 or 0 (true or false, and true by default), specifying whether
	 * to establish a persistent connection or not.
	 * 
	 * @access	public
	 * 
	 */
	var $persistent;

	/**
	 * Constructor method.
	 * 
	 * @access	public
	 * @param	string	$name
	 * @param	string	$host
	 * @param	string	$user
	 * @param	string	$pass
	 * @param	boolean	$persistent
	 * 
	 */
	function PgSQL_Driver ($name = "", $host = "", $user = "", $pass = "", $persistent = 1) {
		$this->name = $name;
		$this->host = $host;
		$this->user = $user;
		$this->pass = $pass;
		$this->persistent = $persistent;
		$this->connect ();
	}

	/**
	 * Establishes a connection with the database
	 * 
	 * @access	public
	 * 
	 */
	function connect () {
		if ($this->persistent) {
			$this->connection = @pg_pconnect ('dbname=' . $this->name . ' host= ' . $this->host . ' user=' . $this->user . ' password=' . $this->pass);
		} else {
			$this->connection = @pg_connect ('dbname=' . $this->name . ' host= ' . $this->host . ' user=' . $this->user . ' password=' . $this->pass);
		}
	}

	/**
	 * Creates and returns a Query object.
	 * 
	 * $sql is the SQL query you wish to execute with this object.
	 * 
	 * @access	public
	 * @param	string	$sql
	 * @return	object
	 * 
	 */
	function query ($sql = "") {
		// inherits full functionality from Database class
	}

	/**
	 * Disconnects from the database.  This method is usually unnecessary
	 * since connections should be automatically terminated or should persist after
	 * the script finishes executing, depending on your settings.
	 * 
	 * @access	public
	 * @return	boolean
	 * 
	 */
	function close () {
		if (@pg_close ($this->connection)) {
			$this->connection = false;
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Retrieves a list of tables in the database and places them in the
	 * $tables property, which is an array.  Returns the list of names on
	 * success and false on failure.
	 * 
	 * @access	public
	 * @return	array
	 * 
	 */
	function getTables (&$db) {
		$res = $db->fetch ("SELECT tablename FROM pg_tables WHERE tablename !~* 'pg_*' ORDER BY tablename");
		if (! $res) {
			return false;
		}
		if (is_object ($res)) {
			$res = array ($res);
		}
		$tables = array ();
		foreach ($res as $obj) {
			$obj_vars = array_values (get_object_vars ($obj));
			$tables[] = array_shift ($obj_vars);
		}
		return $tables;
	}

	// PEAR::DB emulation methods below

	function raiseError ($msg) {
		$this->error = $msg;
		return false;
	}

	function quote ($str = null) {
		switch (strtolower (gettype ($str))) {
			case 'null':
				return 'NULL';
			case 'integer':
			case 'double' :
				return $str;
			case 'boolean':
				return $str ? 'TRUE' : 'FALSE';
			case 'string':
			default:
				$str = str_replace ("'", "''", $str);
				//PostgreSQL treats a backslash as an escape character.
				$str = str_replace ('\\', '\\\\', $str);
				return "'$str'";
		}
	}

	function createSequence ($seq_name) {
		$seqname = db_get_sequence_name ($seq_name);
		//$this->pushErrorHandling(PEAR_ERROR_RETURN);
		$result = db_execute ("CREATE SEQUENCE ${seqname}");
		//$this->popErrorHandling();
		return 1;
	}

	function dropSequence ($seq_name) {
		$seqname = db_get_sequence_name ($seq_name);
		return db_execute ("DROP SEQUENCE ${seqname}");
	}

	function nextId ($seq_name) {
		$seqname = db_get_sequence_name ($seq_name);
		$repeat = false;
		do {
//			$this->pushErrorHandling(PEAR_ERROR_RETURN);
			$result = db_fetch ("SELECT NEXTVAL('${seqname}')");
//			$this->popErrorHandling();
			if ($ondemand && DB::isError($result) &&
				$result->getCode() == DB_ERROR_NOSUCHTABLE) {
				$repeat = true;
				$result = $this->createSequence($seq_name);
				if (DB::isError($result)) {
					return $this->raiseError($result);
				}
			} else {
				$repeat = false;
			}
		} while ($repeat);
		if (DB::isError($result)) {
			return $this->raiseError($result);
		}
		$arr = $result->fetchRow(DB_FETCHMODE_ORDERED);
		$result->free();
		return $arr[0];
	}

}

/**
	 * PgSQL_DatabaseTable provides all of the PgSQL-specific functionality
	 * for the saf.Database.Table package.
	 * 
	 * <code>
	 * <?php
	 * 
	 * $dt = new PgSQL_DatabaseTable ($db, 'tablename', 'pkeycolumn');
	 * 
	 * if ($res = $dt->fetchAll ()) {
	 * 	// do something with $res
	 * } else {
	 * 	echo $dt->error;
	 * }
	 * 
	 * ?>
	 * </code>
	 * 
	 * @author	John Luxford <lux@simian.ca>
	 * @copyright	Copyright (C) 2001-2003, Simian Systems Inc.
	 * @license	http://www.sitellite.org/index/license	Simian Open Software License
	 * @version	1.0, 2002-08-07, $Id: PgSQL.php,v 1.2 2005/07/06 15:30:56 lux Exp $
	 * @access	public
	 * 
	 */

class PgSQL_DatabaseTable extends DatabaseTable {
	/**
	 * Contains a key/value list of database types (regular
	 * expressions are used here to save repeating ourselves) and their
	 * corresponding MailForm widget types.
	 * 
	 * @access	public
	 * 
	 */
	var $typemap = array (
		'bpchar'					=> 'text',
		'char'						=> 'text',
		'varchar'					=> 'text',
		'text'						=> 'textarea',

		'date'						=> 'date',
		'time'						=> 'time',
		'timestamp'					=> 'datetime',
		'.*'						=> 'text',

		// arrays
		// booleans
		// blobs
	);

	/**
	 * Gets all the info it can from the database about this table and
	 * its columns, stores it in the $info property, and parses it into an
	 * associative array ($columns) of MailForm widgets.
	 * 
	 * @access	public
	 * @return	boolean
	 * 
	 */
	function getInfo () {
		if (! $this->info) {
			$fetchsql = 'SELECT 
		a.attnum,
		a.attname AS field, 
		t.typname AS type, 
		a.attlen AS length,
		a.atttypmod AS lengthvar,
		a.attnotnull AS null
	FROM 
		pg_class c, 
		pg_attribute a, 
		pg_type t
	WHERE 
		c.relname = ?
		and a.attnum > 0
		and a.attrelid = c.oid
		and a.atttypid = t.oid
	ORDER BY a.attnum';

			$res = $this->db->fetch ($fetchsql, $this->name);
			if (! $res) {
				$this->error = $this->db->error;
				return false;
			}
			if (is_object ($res)) {
				$res = array ($res);
			}
			$this->info = $res;
		}

		// typemap

		foreach ($this->info as $obj) {
			// parse each column into an object
			$col = new StdClass;

			$col->name = $obj->field;

			foreach ($this->typemap as $regex => $type) {
				if (preg_match ('/^' . $regex . '$/', $obj->type, $regs)) {
					$col->type = $type;
					break;
				}
			}

			if (! is_array ($this->db->tables)) {
				$this->db->getTables ();
			}

			if (preg_match ('/^(' . join ('|', $this->db->tables) . ')_id$/i', $col->name, $regs)) {
				$col->type = 'ref';
				$col->table = $regs[1];
				if ($col->table == $col->name) {
					$col->self_ref = true;
				}
			}

			if ($obj->null != 'f') {
				$col->nullable = true;
			}

			$this->columns[$col->name] = $this->_makeWidget ($col);
		}
		return true;
	}

	/**
	 * Gets the name of the primary key field for this table using the
	 * results of getInfo() (see below).  Used by the constructor method to
	 * set the $pkey property if a primary key column was not specified.
	 * Returns false on failure.
	 * 
	 * @access	public
	 * @return	string
	 * 
	 */
	function getPkey () {
		if ($this->pkey) {
			return $this->pkey;
		}

		if (! $this->info) {
			if (! $this->getInfo ()) {
				return false;
			}
		}

		// we got $this->info

		foreach ($this->info as $obj) {
			if ($obj->Key == 'PRI') {
				return $obj->Field;
			}
		}

		return false;
	}

	/**
	 * Uses the global $tables array (Sitellite CMS specific) to get
	 * the primary key, referencing column, display column, and a true or false
	 * self-reference value, when given a Ref column name and its corresponding
	 * table.
	 * 
	 * @access	public
	 * @param	string	$name
	 * @param	string	$table
	 * @return	boolean
	 * 
	 */
	function getRefInfo ($name, $table) {
		// returns array of pkey, refcol, displaycol, and self_ref

		global $tables;

		$ret = array ();
		$ret[] = $tables[$table]->primary_key;
		$ret[] = $name;

		$dcols = array ();
		if ($tables[$table]->columns[$tables[$table]->primary_key]->type != 'hidden') {
			$dcols[] = $tables[$table]->primary_key;
		}
		foreach ($tables[$table]->columns as $c) {
			if ($c->name != $tables[$table]->primary_key) {
				if (! preg_match ('/^(hidden|file|password)$/', $c->type)) {
					$dcols[] = $c->name;
					if (count ($dcols) >= 2) {
						break;
					}
				}
			}
		}
		if (count ($dcols) == 0) {
			$ret[] = $tables[$table]->primary_key;
		} else {
			// note: this line uses a PgSQL-specific function
			$ret[] = 'CONCAT(' . join (', ", ", ', $dcols) . ')';
		}


		if ($this->name == $table) {
			$ret[] = true;
		} else {
			$ret[] = false;
		}

		return $ret;
	}
}



?>